initSidebarItems({"enum":[["PadLocation",""],["PadSliceStrategy",""],["SliceConcatenateStrategy",""]],"fn":[["access_reshape_to_relay",""],["access_slice_access_transpose_composition_commutative",""],["add_bias_add_to_dense","Experimental rewrite to add a bias add on any dense."],["add_relay_to_glenside",""],["batch_flatten_relay_to_glenside",""],["bias_add_relay_to_glenside",""],["bubble_access_concatenate_through_access",""],["bubble_access_concatenate_through_access_cartesian_product_not_item_axis_left",""],["bubble_access_concatenate_through_access_cartesian_product_not_item_axis_right",""],["bubble_access_concatenate_through_access_cartesian_product_same_item_axis",""],["bubble_access_concatenate_through_access_slice",""],["bubble_access_concatenate_through_access_transpose",""],["bubble_access_concatenate_through_compute_dot_product_item_axis",""],["bubble_access_concatenate_through_compute_dot_product_not_item_axis","When bubbling up through (compute dot-product …), what you do depends on whether you’re concatenating along an item axis or not. If you are not, it’s easy: you just bubble it straight through. If you are, then you are concatenating along an axis that’s getting reduced in the reduction sum. So we need to explicitly insert another reduction."],["bubble_access_reshape_through_compute_reduce_max","Moves a reshape through a compute reduce-max. We do this by simply throwing away the shape associated with the compute dimensions."],["bubble_access_slice_through_access_cartesian_product_not_item_axis_left",""],["bubble_access_slice_through_access_cartesian_product_not_item_axis_right",""],["bubble_access_slice_through_access_cartesian_product_same_item_axis",""],["bubble_access_slice_through_access_pad_inequal_axes",""],["bubble_access_slice_through_compute_dot_product_item_axis_not_tuple_axis","If we’re slicing in an item axis that isn’t the tuple axis (i.e. the first item axis), then computing before slicing has the potential to affect the computation, as it is adding data. So we need to be able to prove that this region will not affect the computation."],["bubble_access_slice_through_compute_dot_product_not_item_axis","If we’re not slicing in an axis that’s being computed over, then removing the slice has no potential to effect the computation. It will just result in a larger computation, with some of the data being sliced away."],["bubble_access_through_access_transpose","Both directions of this rewrite are trivial."],["bubble_access_transpose_through_access_pad",""],["bubble_concatenate_through_cartesian_product_axis_0_0",""],["bubble_concatenate_through_cartesian_product_last_axis",""],["bubble_concatenate_through_cartesian_product_not_last_axis_left",""],["bubble_concatenate_through_cartesian_product_not_last_axis_right",""],["bubble_reshape_through_cartesian_product",""],["bubble_reshape_through_compute_dot_product",""],["bubble_reshape_through_linear",""],["bubble_reshape_through_linear_generalized","Model rewrite If we know how to implement them (a computation) in relay"],["collapse_nested_access_slices",""],["collapse_nested_accesses",""],["collapse_nested_transposes",""],["concatenate_relay_to_glenside",""],["conv1d_relay_to_glenside",""],["conv2d_on_hlscnn",""],["conv2d_relay_to_glenside",""],["dense_relay_to_glenside",""],["divide_relay_to_glenside",""],["dot_product_to_linear",""],["dot_product_with_vta",""],["eliminate_expand_dims_zero_num_newaxis",""],["expand_dims_relay_to_glenside",""],["flatten_dot_product_to_dense",""],["flatten_unflatten_any_access",""],["flexasr_maxpool","Rewrite mapping maxpools to the FlexASR accelerator."],["glenside_matmul_to_relay_dense","Experimental rewrite to convert Glenside matmuls into Relay denses. Pretty straightforward; only experimental b/c adding the night before PLDI deadline."],["global_avg_pool2d_relay_to_glenside_nchw",""],["has_shape",""],["is_symbol","short_circuit lets us return early if we don’t actually care about the result of this check. This is the easiest way I could find to do this using egg’s conditional appliers. TODO(@gussmith23) make this cleaner"],["linear_layer_accelerator_rewrites","the user of the accelerator will give us a pattern written in Relay (bias_add (dense ?x ?w) ?bias)Compile this pattern to a Glenside version patternAdd the following rewrite: from the Glenside version of the pattern to an accelerator call"],["lstm_to_flexasr",""],["max_pool2d_relay_to_glenside_nchw",""],["multiply_relay_to_glenside",""],["negative_relay_to_glenside",""],["pad_relay_to_glenside",""],["pad_slice_accesses",""],["reassociate_max","Breaks a large reduce-max into smaller reduce-maxes which are then reduced by the original reduce-max."],["relay_dense_rewrite",""],["relay_to_glenside_rewrites",""],["relu_relay_to_glenside",""],["remove_trivial_transpose",""],["reshape_relay_to_glenside",""],["rewrite_nonmatching_cartesian_product_concatenate",""],["simplify_multiple_access_reshapes",""],["simplify_multiple_accesses",""],["simplify_multiple_transposes",""],["simplify_reduce_max","Simplify away a reduce-max of a single element by rewriting it to a simple reshape. I.e. a reduce-max over `((...), (1, ..., 1))` gets rewritten to a reshape which reshapes to `((...), ())`. My previous version of this rewrite was seeming to cause bugs; if things go wrong, disable this rewrite first!"],["simplify_tuple_get_item",""],["slice_concatenate_accesses",""],["slice_concatenate_tensor_accesses",""],["softmax_relay_to_glenside",""],["sqrt_relay_to_glenside",""],["squeeze_relay_to_glenside",""],["systolic_array",""],["systolic_array_conv2d_im2col_fc_with_blocking","TODO(@gussmith23) This is a hack This is pretty hyper-specific to how we currently implement conv2d when reading from Relay. That is, to implement conv2d, we transpose to NCHW"],["systolic_array_conv2d_im2col_nchw_oihw_with_blocking",""],["systolic_array_conv2d_im2col_nhwc_hwio_with_blocking",""],["systolic_array_conv2d_nchw_oihw_with_blocking",""],["systolic_array_conv2d_nhwc_hwio_with_blocking",""],["systolic_array_with_blocking","Tensorizes a computation to an externally-blocked systolic array."],["transpose_relay_to_glenside",""]],"struct":[["RewriteNonMatchingCartConcatenateApplier",""]]});