initSidebarItems({"enum":[["ArgValue","A borrowed TVMPODValue. Can be constructed using `into()` but the preferred way to obtain a `ArgValue` is automatically via `call_packed!`."],["ByteArray","A newtype wrapping a raw TVM byte-array."],["DeviceType","Device type represents the set of devices supported by TVM."],["Error",""],["NDArrayError",""],["RetValue","An owned TVMPODValue. Can be converted from a variety of primitive and object types. Can be downcasted using `try_from` if it contains the desired type."]],"fn":[["debug_print",""],["get_last_error","Gets the last error message."],["version","Outputs the current TVM version."]],"macro":[["check_call",""],["external",""],["tvm_call",""]],"mod":[["array",""],["device",""],["errors",""],["function","This module provides an idiomatic Rust API for creating and working with TVM functions."],["graph_rt",""],["map",""],["module","Provides the [`Module`] type and methods for working with runtime TVM modules."],["ndarray","This module implements the [`NDArray`] type for working with TVM tensors or coverting from a Rust’s ndarray to TVM `NDArray`."],["object",""],["string",""]],"struct":[["DataType",""],["Device",""],["Function","An owned thread-safe version of `tvm::PackedFunc` for consumption in Rust."],["FunctionNotFoundError",""],["Module",""],["NDArray",""],["Object","A TVM intrusive smart pointer header, in TVM all FFI compatible types start with an Object as their first field. The base object tracks a type_index which is an index into the runtime type information table, an atomic reference count, and a customized deleter which will be invoked when the reference count is zero."],["ObjectPtr","A smart pointer for types which implement IsObject. This type directly corresponds to TVM’s C++ type ObjectPtr."],["ObjectRef",""],["String",""],["StringObj",""],["TypeMismatchError",""]],"trait":[["AsArgValue",""],["IsObject","An unsafe trait which should be implemented for an object subtype."],["IsObjectRef",""]]});